################################################################################
# Parse tree data structures
#
# A parse tree is conceptually a pair of
#   * a grammar symbol, which is an object (usually, but not always, a symbol)
#     identifying the terminal or non-terminal matching that parse tree
#   * a possibly-empty list of sub-trees
#
# We represent parse trees as a struct owning a linked list of sub-trees. The
# linked list is implemented using a __parse_tree_node data structure, which
# wraps a sub-tree and a pointer to the next node.
#

# __parse_tree_nil implements the __parse_tree_node interface, but it is a
# singleton representing the empty list.
__parse_tree_nil{^} ({
    each{^} {
        {^f
            .
        }
    };

    if_nil{^} {
        {^t{^f
            ^t[]
        }}
    };

    equals{^} {
        {^other
            ^other if_nil {
                true
            } {
                false
            }
        }
    };

    {^msg
        ^msg[]
    }
}[]);

__bind __parse_tree_node __init {^self{^tree
    ^self tree (^tree);
    ^self next (__cell[]);
    ^self next{__parse_tree_nil}
}};

__bind __parse_tree_node each {^self{^f
    ^f (^self tree);
    ^self next{^} each ^f
}};

__bind __parse_tree_node if_nil {^self{^t{^f
    ^f[]
}}};

__bind __parse_tree_node equals {^self{^other
    (^other if_nil) {
        false
    } {
        (^self tree) == (^other tree) if_true {
            (^self next{^}) equals (^other next{^})
        } {
            false
        }
    }
}};

__bind parse_tree __init {^self{^sym
    ^self symbol ^sym;

    ^self _head (__cell[]);
    ^self _head {__parse_tree_nil};

    ^self _tail (__cell[]);
    ^self _tail {__parse_Tree_nil};

    .
}};

__bind parse_tree == {^self{^other
    __call {
        (^self symbol) == (^other symbol) if_true {
            (^self _head{^}) equals (^other _head{^})
        } {
            false
        }
    }
}};

__bind parse_tree each {^self{^f
    ^self _head{^} each ^f
}};

__bind parse_tree is_terminal {^self
    # By definition, a tree represents a terminal if and only if it has no
    # sub-trees.
    ^self _head{^} if_nil {
        true
    } {
        false
    }
};

__bind parse_tree push {^self{^tree
    # Create a new, isolated list node representing ^tree, and call it ^node.
    {^node
        # Append the node to the linked list.
        ^self _tail{^} if_nil {
            (^self) _head{(^node)};
            (^self) _tail{(^node)}
        } {
            (^self) _tail{^} next {(^node)};
            (^self) _tail{(^node)}
        }
    } (__new __parse_tree_node ^tree);

    ^self
}};

__bind parse_tree render {^self{^out
    ^out `[` (^self symbol) `|`;
    ^self each {^sub_tree
        ^sub_tree render ^out
    };
    ^out `|]`
}};

# Create an object implementing the low-level parse tree protocol understood by
# the built-in macro construct, representing the same tree as this parse tree.
__bind parse_tree __inner {^self
    {^out
        ^self each {^sub_tree
            ^out (^sub_tree __inner)
        };
        ^self symbol
    }
};

# Construct a high-level parse_tree instance from an object implementing the
# low-level parse tree protocol.
__parse_tree_from_inner{^} {^t
    {
        # We'll build a linked list of the sub-trees locally, as we visit the
        # children of ^t. Once we have all of ^t's children (and its grammar
        # symbol, which we can only get after visiting it) we will move the
        # children and grammar symbol into a new parse_tree object.
        head{^} (__cell[]);
        head{__parse_tree_nil};
        tail{^} (__cell[]);
        tail{__parse_tree_nil};

        # Visit the children of ^t and get the return value ^sym, which is the
        # grammar symbol of the parse tree.
        {^sym
            # Construct a new parse_tree with ^sym and set its head and tail.
            {^t
                ^t _head {head{^}};
                ^t _tail {tail{^}};
                ^t
            } (__new parse_tree ^sym)
        } (
            ^t {^sub_tree
                # For each child of ^t, recursively use __parse_tree_from_inner
                # to build a high-level parse_tree representing the child, and
                # then  construct a new isolated list node from that tree.
                {^node
                    # Append the new node to our local list.
                    tail{^} if_nil {
                        head{(^node)};
                        tail{(^node)}
                    } {
                        tail{^} next {(^node)};
                        tail{(^node)}
                    }
                } (__new __parse_tree_node (__parse_tree_from_inner ^sub_tree))
            }
        )
    }[]
};

################################################################################
# __kleene_for
#
# Loop over a parse tree returned from a Kleene star production. A Kleene star
# production is one of a pair of productions of the form
#
#   K -> {term}
#   K -> {term} {K}
#
# Actually this represents the + operator rather than the Kleene star *, but it
# is equivalent to (term)(term)*, which is close enough.
#
# Productions which are intended to be used with `__kleene_for` must return a
# parse tree of a specific form: an outer parse tree with a single child, which
# in turn contains one child for each term in the sequence. With such a parse
# tree, the recursive structure of these sequences has been linearized into a
# single, shallow parse tree with many children, rather than a deep parse tree
# with only one or two children at each level. This allows for easier iteration.
# The purpose of the outer parse tree is to prevent the inner parse tree from
# being reparsed, since if it contains many children it will probably not be a
# valid parse tree on its own.
#
# For example, the Kleene parse tree for the singleton sequence `term` would be
#   ((term ; 7) ; 6)
# The parse tree for the sequence `term1 term2 term3` would similarly be
#   ((term1 term2 term3 ; 7) ; 6)
# Note how the inner parse tree (term1 term2 term3 ; 7) is invalid; it does not
# match any production for its non-terminal `7`. But it is protected from
# reparsing by the outer parse tree.
#
# This macro takes such a parse tree object and a block, and applies the block
# to each term in the inner parse tree.
{\> {^{`__kleene_for`} {^{``}; 6} {^{``}; 7}; 3} {^toks
    {
        n_ref{^ ^};
        n n_ref;
        n_ref _0;

        terms{^ ^};
        do{^ ^};
        ^toks {^tok
            {
                _0{^{{
                    n_ref _1
                }}};
                _1{^{{
                    terms {(^tok)};
                    n_ref _2
                }}};
                _2{^{{
                    do {(^tok)};
                    n_ref _3
                }}};

                n[] []
            }[]
        };

        {^ (terms[]) {`{`} {`^term`}
            {`^term`} (do[])
          {`}`};
          3
        }
    }[]
}};

################################################################################
# QuasiQuote syntax for creating parse trees
#
# The expression [n|input to parser|] is a parse_tree representing the result of
# parsing the text "input to parser" as the non-terminal `n`. The non-terminal
# symbol is optional and defaults to 1, so [|input|] is the same as [1|input|].
#
# Expressions representing parse trees can be interpolated into the new parse
# tree using ${}, as in [|${recv} msg|], which is a parse tree representing the
# expression that sends `msg` to whatever expression is represented by the
# parse_tree `recv`.
#

# Literal terms (which we convert to terminal parse trees).
{\> {^{^{``}; symbol}; term}  {^toks
    {
        sym{^ ^};
        ^toks{^sub_tree
            ^sub_tree {^sym
                sym{(^sym)}
            }
        };
        {^ {`(`} {`__new`} {`parse_tree`} (sym[]) {`)`}; 6}
    }[]
}};

# For commonly used tokens which cannot be lexed as symbols even in a context
# where a symbol is the only expected token, we define rules that accept that
# token and convert it to a terminal parse tree.
#
# This is only necessary due to current limitations of the lexer. The lexer
# should be made extensible from bl:mp or at least given better defaults, after
# which time we should be able to achieve this in a much more general way.
{\> {^{`(`}; term}  {^toks
    {^ {`(`} {`__new`} {`parse_tree`} {^{`(`}; 7} {`)`}; 6}
}};
{\> {^{`)`}; term}  {^toks
    {^ {`(`} {`__new`} {`parse_tree`} {^{`)`}; 7} {`)`}; 6}
}};
{\> {^{`{`}; term}  {^toks
    {^ {`(`} {`__new`} {`parse_tree`} {^{`{`}; 7} {`)`}; 6}
}};
{\> {^{`}`}; term}  {^toks
    {^ {`(`} {`__new`} {`parse_tree`} {^{`}`}; 7} {`)`}; 6}
}};
{\> {^{`!`}; term}  {^toks
    {^ {`(`} {`__new`} {`parse_tree`} {^{`!`}; 7} {`)`}; 6}
}};


# Interpolated expressions as terms representing sub-trees.
{\> {^{`$`} {`{`} {^{``}; 1} {`}`}; term} {^toks
    {
        n_ref{^ ^};
        n n_ref;
        n_ref _0;

        term{^ ^};
        ^toks {^tok
            {
                _0{^{{
                    # $
                    n_ref _1
                }}};
                _1{^{{
                    # {
                    n_ref _2
                }}};
                _2{^{{
                    term{(^tok)};
                    n_ref _3
                }}};
                _3{^{{
                    # }
                    n_ref _4
                }}};
                n[] []
            }[]
        };

        term[]
    }[]
}};

{\> {^{^{``}; term}; terms} {^toks
    {^ {(^toks) ^; 7}; 6}
}};

{\> {^{^{``}; term} {^{``}; terms}; terms} {^toks
    {
        n_ref{^ ^};
        n n_ref;
        n_ref _0;

        head{^ ^};
        tail{^ ^};
        ^toks {^tok
            {
                _0{^{{
                    head {(^tok)};
                    n_ref _1
                }}};
                _1{^{{
                    tail {(^tok)};
                    n_ref _2
                }}};
                n[] []
            }[]
        };

        {^{^out
            ^out(head[]);
            __kleene_for(tail[]) {^term
                ^out ^term
            };
            7
        }; 6}
    }[]
}};

# The basic quasiquote syntax.
{\> {^{`[`} {^{``}; 7} {`|`} {^{``}; terms} {`|]`}; 7} {^toks
    {
        n_ref{^ ^};
        n n_ref;
        n_ref _0;

        nt{^ ^};
        terms{^ ^};
        ^toks {^tok
            {
                _0{^{{
                    # [
                    n_ref _1
                }}};
                _1{^{{
                    nt {(^tok)};
                    n_ref _2
                }}};
                _2{^{{
                    # |
                    n_ref _3
                }}};
                _3{^{{
                    terms {(^tok)};
                    n_ref _4
                }}};
                _4{^{{
                    # |]
                    n_ref _5
                }}};

                n[] []
            }[]
        };

        {^out
            ^{`__new`} {`parse_tree`} (nt[]);
            __kleene_for (terms[]) {^term
                ^out {`push`} {(^term) ^; 7}
            };
            3
        }
    }[]
}};

# `terms` is always non-empty, so we define a separate production for an empty
# parse tree.
{\> {^{`[`} {^{``}; 7} {`|`} {`|]`}; 7} {^toks
    {
        n_ref{^ ^};
        n n_ref;
        n_ref _0;

        nt{^ ^};
        terms{^ ^};
        ^toks {^tok
            {
                _0{^{{
                    # [
                    n_ref _1
                }}};
                _1{^{{
                    nt {(^tok)};
                    n_ref _2
                }}};
                _2{^{{
                    # |
                    n_ref _3
                }}};
                _3{^{{
                    # |]
                    n_ref _4
                }}};

                n[] []
            }[]
        };

        {^{`__new`} {`parse_tree`} (nt[]); 3}
    }[]
}};

# If no non-terminal symbol is given, default to 1.
{\> {^{`[|`} {^{``}; terms} {`|]`}; 7} {^toks
    {
        n_ref{^ ^};
        n n_ref;
        n_ref _0;

        nt{^ ^};
        terms{^ ^};
        ^toks {^tok
            {
                _0{^{{
                    # [|
                    n_ref _1
                }}};
                _1{^{{
                    terms {(^tok)};
                    n_ref _2
                }}};
                _2{^{{
                    # |]
                    n_ref _3
                }}};

                n[] []
            }[]
        };

        {^out
            ^{`[`} {`1`} {`|`} (terms[]) {`|]`};
            7
        }
    }[]
}};

################################################################################
# grammar_symbol
#
# Here we define a grammar for symbols which can appear in the production
# portion of a macro definition. These are either terminals (which are just
# symbols) or non-terminals (the symbol naming the non-terminal, enclosed in
# <>).
#

# A non-terminal which just reduces symbols. This is just because it's slightly
# nicer to write {symbol} than `\`sym\``.
{\> {^{`\`sym\``}; symbol} {^toks
    {
        sym{^ ^};
        ^toks{^sym
            sym{(^sym[])}
        };
        {^{^{sym[]}; 7}; 6}
    }[]
}};

# Terminal symbols.
{\> {^{^{``}; symbol}; grammar_symbol}  {^toks
    {
        sym{^ ^};
        ^toks{^sub_tree
            ^sub_tree {^sym
                sym{(^sym)}
            }
        };
        {^ {`{`} (sym[]) {`}`}; 6}
    }[]
}};

# Non-terminal symbols.
{\> {^ {<} {^{``}; symbol} {>}; grammar_symbol} {^toks
    {
        n_ref{^ ^};
        n n_ref;
        n_ref _0;

        nt{^ ^};
        ^toks {^tok
            {
                _0{^{{
                    # <
                    n_ref _1
                }}};
                _1{^{{
                    (^tok) {^sym
                        nt{(^sym)}
                    };
                    n_ref _2
                }}};
                _2{^{{
                    # >
                    n_ref _3
                }}};

                n[] []
            }[]
        };

        # Return a parse tree object with the given non-terminal; that is, a
        # block with a single child and which returns the non-terminal. This is
        # how we represent non-terminals in low-level, built-in macro
        # definitions.
        {^ {`{`} {`^`} {`{`} {``} {`}`} {`;`} (nt[]) {`}`}; 6}
    }[]
}};

################################################################################
# pattern
#
# A pattern is a grammar_symbol with an optional name, written name@symbol. If
# provided, the name will be bound to the sub-parse-tree matched by the symbol
# in the macro handler.
#
# The ad-hoc parse tree returned by these macros cannot be converted to an
# expression, but it can be traversed using __kleene_for to yield a sequence
# (name, symbol).
#
# If no name is given in the pattern, the `name` field in the result will be
# `_`.
#

# No-name patterns.
{\> {^{^{``}; grammar_symbol}; pattern} {^toks
    {
        ret{^ ^};

        # ^toks is a parse tree of the form ((... ; grammar_symbol) ; pattern).
        # Traverse it to get to the grammar_symbol sub-tree, and return a
        # singleton Kleene sequence containing the symbol `_` and the contents
        # of that sub-tree.
        ^toks {^sym
            ret{
                {^{^ {_}; ^sym ^; 7}; 6}
            }
        };
        ret[]
    }[]
}};

# Named patterns.
{\> {^{^{``}; symbol} {`@`} {^{``}; grammar_symbol}; pattern} {^toks
    {
        n_ref{^ ^};
        n n_ref;
        n_ref _0;

        binder{^ ^};
        symbol{^ ^};
        ^toks {^tok
            {
                _0{^{{
                    binder {(^tok)};
                    n_ref _1
                }}};
                _1{^{{
                    # @
                    n_ref _2
                }}};
                _2{^{{
                    symbol {(^tok)};
                    n_ref _3
                }}};
                n[] []
            }[]
        };

        {^{(binder[]) ^; (symbol[]) ^; 7}; 6}
    }[]
}};

# A singleton Kleene sequence of patterns.
{\> {^{^{``}; pattern}; patterns} {^toks
    {^ {(^toks) ^; 7}; 6}
}};

# A non-trivial Kleene sequence of patterns.
{\> {^{^{``}; pattern} {^{``}; patterns}; patterns} {^toks
    {
        n_ref{^ ^};
        n n_ref;
        n_ref _0;

        head{^ ^};
        tail{^ ^};
        ^toks {^tok
            {
                _0{^{{
                    head {(^tok)};
                    n_ref _1
                }}};
                _1{^{{
                    tail {(^tok)};
                    n_ref _2
                }}};
                n[] []
            }[]
        };

        {^{^out
            ^out(head[]);
            __kleene_for(tail[]) {^term
                ^out ^term
            };
            7
        }; 6}
    }[]
}};

################################################################################
# Macro definitions
#

# Run-time functions used by macro handlers defined using `syntax`.
__pat_head{^} {^iter
    {
        __h{^ ^};
        ^iter { ^x
            __h {(^x)}
        };
        __h[]
    }[]
};

__pat_tail {^} {^iter {^visit
    n_ref{^ ^};
    n n_ref;
    n_ref _0;
    ^iter {^x
        {
            _0{^{{
                n_ref _1
            }}} ;
            _1{^{{
                (^visit ^x)
            }}};
            n[] []
        }[]
    }
}};

{\> {^ {`syntax`} {`\`sym\``} {`->`} {^{``}; patterns} {`{`} {^{``}; 1} {`}`}; 3} {^toks
    {
        n_ref{^ ^};
        n n_ref;
        n_ref _0;

        nt{^ ^};
        patterns{^ ^};
        handler{^ ^};
        ^toks {^tok
            {
                _0{^{{
                    # syntax
                    n_ref _1
                }}};
                _1{^{{
                    nt {(^tok)};
                    n_ref _2
                }}};
                _2{^{{
                    # ->
                    n_ref _3
                }}};
                _3{^{{
                    patterns {(^tok)};
                    n_ref _4
                }}};
                _4{^{{
                    # {
                    n_ref _5
                }}};
                _5{^{{
                    handler {(^tok)};
                    n_ref _6
                }}};
                _6{^{{
                    # }
                    n_ref _7
                }}};

                n[] []
            }[]
        };

        # Helper function for traversing the sequence of patterns from the macro
        # definition.
        visit_patterns{^} {^pats{^visit
            __kleene_for ^pats {^pat
                {
                    # The pattern itself is a Kleene sequence with two terms,
                    # the binder and the grammar symbol. Traverse the sequence
                    # to extract these terms and then pass them to the visitor.
                    n_ref _0;
                    binder{^ ^};
                    sym{^ ^};
                    __kleene_for ^pat {^sym
                        {
                            _0{^{{
                                binder{(^sym)};
                                n_ref _1
                            }}};
                            _1{^{{
                                sym{(^sym)};
                                n_ref _2
                            }}};
                            n[] []
                        }[]
                    };

                    ^visit(sym[])(binder[])
                }[]
            }
        }};

        # Helpers for generating code that traverses the ^toks argument to the
        # generated macro handler. Calling `next_tok` will return a parse tree
        # which, when evaluated, accesses the next parse tree in ^toks. It will
        # then advance curr_tok so that the next time `next_tok` is called, it
        # generates code for the following sub-tree.
        curr_tok_ref{^ ^};
        curr_tok curr_tok_ref;
        curr_tok_ref {{^{`^toks`}; 7}};
            # `curr_tok` should always represent the sequence of tokens not yet
            # visited. Initialize it to the whole sequence, and each time we
            # advance by one we will add an application of `__pat_tail` to
            # represent the next sub-tree.
        next_tok{^} {
            {^curr
                curr_tok_ref {{^ {`__pat_tail`} ^curr; 7}};
                {^ {`__pat_head`} ^curr; 1}
            } (curr_tok[])
        };

        {^out
            ^{`{`} {`\\>`} {`{`};
                visit_patterns (patterns[]) {^sym{^binder
                    ^out {`^`} ^sym {`;`}
                }};
                ^(nt[]);
            ^{`}`};

            ^{`{`} {`^toks`};
                ^ {`{`};
                    ^ {`__call`} {`{`};
                        visit_patterns (patterns[]) {^sym{^binder
                            ^out ^binder {`:=`}
                                {`(`} {`__parse_tree_from_inner`}
                                    {`(`} (next_tok[]) {`)`} {`)`} {`;`}
                        }};
                        ^{`(`}(handler[]){`)`} {`__inner`};
                    ^{`}`};
                ^{`}`} {`[]`};
            ^{`}`} {`}`};

            1
        }
    }[]
}};

.
