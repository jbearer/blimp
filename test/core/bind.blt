#: --racket-timeout=20

# Test a simple method that just returns a value
bind class.get_const foo;

{class|.}{.get_const|.}{!expect|foo};
{do|
    c {:=| {class|.}};
    c{.get|.}{.get_const|.}{!expect|foo}
} {.eval|.};

# Test a simple method with side-effects
bind class.set_x (
    x{:=| (that{.get|.}){.eval|.} };
    y
);
bind class.get_x (
    x{.get|.}
);

{do|
    c {:=| {class|.}};
    ((c{.get|.}) {.set_x|a}) {!expect|y};
    ((c{.get|.}) {.get_x|.}) {!expect|a}
} {.eval|.};

# Test setting a variable in a scope does not set the variable on the receiver.
bind class.dont_set_y ({do|
    y {:=| a }
} {.eval|.});
{do|
    c {:=| {class|.} };
    (c{.get|.}) {.dont_set_y|.};
    {do| (c{.get|.}) {.get_y|.} } {!expect_error|.}
} {.eval|.};

bind class.set_x (
    x{:=| (that{.get|.}){.eval|.} };
    y
);
bind class.get_x (
    x{.get|.}
);

# Test calling a method on the receiver in a scope.
bind class.tricky_set_x ({do|
    arg{:=|that{.get|.}};
        # We have to save the value of `that`, because we're about to send
        # another message to `this`, which will overwrite that. Since we're now
        # setting the value of `arg` in a new, anonymous scope, we know it will
        # be safe no matter what the next message send does.
    (this{.get|.}) {.set_x|(arg{.get|.}){.eval|.}}
} {.eval|.});
{do|
    c {:=| {class|.} };
    (c{.get|.}) {.tricky_set_x|a};
    ((c{.get|.}) {.get_x|.}) {!expect|a}
} {.eval|.};

.
