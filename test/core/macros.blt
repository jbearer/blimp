#: --skip-racket

################################################################################
# Simplest possible macro: create a new token and define it to a symbol.
#
# Kind of like `#define my_keyword foo`
#

# Before the macro is parsed, `my_keyword` just parses to `my_keyword`.
!expect_error {
    !expect_eq my_keyword foo
};

# Define the macro.
\> {^ my_keyword; 7} {^toks
    {^ foo; 7}
};

# Once the macro has been parsed, `my_keyword` parses to `foo`.
!expect_eq my_keyword foo;

################################################################################
# Defining macros for precedences, and using them to define new macros.
#

# Define an alias @@term for the precedence level 7.
\> {^ {6}; ^ `@@term`; ^ {6}; 3} {^toks
    {
        n_ref{^ ^};
        n n_ref;
        n_ref 0;

        macro{^ ^};
        handler{^ ^};
        ^toks {^tok
            {
                0{^{{
                    macro {(^tok)};
                    n_ref 1
                }}};
                1{^{{
                    n_ref 2
                }}};
                2{^{{
                    handler {(^tok)};
                    n_ref 3
                }}};

                n[] []
            }[]
        };

        {^ `\\>`; ^ `{` `(`(macro[])`)` `^` `;` `7` `}`; ^ (handler[]); 3 }
    }[]
};

# Define a new macro at precedence 7 using the @@term alias.
{^ `my_keyword2`} @@term {{^ bar; 7}};
!expect_eq my_keyword2 bar;

# Do it again, make sure the handler is idempotent.
{^ `my_keyword3`} @@term {{^ baz; 7}};
!expect_eq my_keyword3 baz;

# Old macros should still work.
!expect_eq my_keyword foo;

# Just straight-up define @term to 7
{^ `@term`} @@term {{^ 7; 7}};

# Define a new macro at precedence 7 using the @term alias.
\> {^ `my_keyword20`; @term} {{^ foo; 7}};
!expect_eq my_keyword20 foo;

# Define a macro with a 7-level parameter using the @term alias.
\> {^ `my_keyword21`; ^{@term}; @term} {{^ bar; 7}};
!expect_eq my_keyword21 {^} bar;

################################################################################
# Macros do not take effect until everything we have parsed has lower precedence
# than the first token of the macro. And, new tokens introduced by the macro are
# not lexed until the macro takes effect.
#

(
    \> {^ {7} `when_will_we_lex_this_token`; 3} {{^`foo`; 7}};
    !expect_eq ({^} when_will_we_lex_this_token) `when_will_we_lex_this_token`
);
!expect_eq ({^} when_will_we_lex_this_token) `foo`;

################################################################################
# Defining a macro in the production tree for another macro.
#

\> {
    \> {^ `my_keyword4`; 7} {{^`foo`;7}};
    ^ `my_keyword5`;
    7
} {
    {^ `my_keyword4`;7}
};

!expect_eq my_keyword4 foo;

################################################################################
# Defining a macro in the handler for another macro.
#

\> {^ `my_keyword6`; 7} {
    \> {^`my_keyword7`;7} {{^`bar`;7}};
    {^`my_keyword7`;7}
};

!expect_eq my_keyword6 bar;

################################################################################
# Defining a macro in the expansion of another macro.
#

\> {^`define_in_expansion`; 7} {
    {
        ^`\\>`; ^`{`; ^`^`; ^`defined_in_expansion`; ^`;`; ^`7`; ^`}`; ^`{`;
            ^`{`; ^`^`; ^`foo`; ^`;`; ^`7`; ^`}`;
        ^`}`; ^`;`;
        ^`defined_in_expansion`;
        1
    }
};

!expect_eq define_in_expansion `defined_in_expansion`;
    # The use of `defined_in_expansion` in the expansion of
    # `define_in_expansion` does not itself get expanded to `foo`, because macro
    # expansions are not piped through the lexer, since they are already
    # formatted as a stream of tokens. So adding the keyword
    # `defined_in_expansion` does not affect the token `defined_in_expansion`
    # later in the expansion, which has already been lexed as a symbol.
!expect_eq defined_in_expansion foo;

# If we do the same thing, but now use a token that already exists for the macro
# within the macro, then we should be able to use the inner macro in the
# expansion of the outer one.
\> {^`+`; ^`-`; ^`*`; 7} {{^ foo;7}};

\> {^`define_in_expansion2`; 7} {
    {
        ^`\\>`; ^`{`; ^`^`; ^`\`+\``; ^`;`; ^`^`; ^`\`+\``; ^`;`; ^`7`; ^`}`; ^`{`;
            ^`{`; ^`^`; ^`bar`; ^`;`; ^`7`; ^`}`;
        ^`}`; ^`;`;
        ^`+`; ^`+`;
        1
    }
};

!expect_eq define_in_expansion2 bar;
!expect_eq + + bar;

################################################################################
# Macros may take effect during reparsing of the expansion of another macro, but
# not take effect until sometime later outside of the expansion.
#

\> {^`define_in_expansion3`; 7} {
    {
        ^`\\>`; ^`{`; ^`^`; ^`{`; ^`7`; ^`}`; ^`;`; ^`^`; ^`\`-\``; ^`;`; ^`3`; ^`}`; ^`{`;
            ^`{`; ^`^`; ^`foo`; ^`;`; ^`7`; ^`}`;
        ^`}`; ^`;`;
        ^`bar`; ^`-`;
        1
    }
};

{
    !expect_eq define_in_expansion3 foo
}[];
!expect_eq (bar-) foo;

# If we try to use the macro defined in the expansion while in a nested
# expression, it won't expand, but neither will the newly defined token be
# lexed, so we can use it as a normal symbol.
\> {^`define_in_expansion4`; 7} {
    {
        ^`\\>`; ^`{`; ^`^`; ^`{`; ^`7`; ^`}`; ^`;`; ^`^`; ^`\`*\``; ^`;`; ^`3`; ^`}`; ^`{`;
            ^`{`; ^`^`; ^`foo`; ^`;`; ^`7`; ^`}`;
        ^`}`; ^`;`;
        ^`bar`; ^`*`;
        1
    }
};
{
    define_in_expansion4;
    !expect_eq (bar*) bar;
        # Here, bar* simply parses as a send `bar` `*`. Since `bar` is an
        # undefined symbol, a reference to `bar` is passed to `*`, which is also
        # an undefined symbol, so the result is a reference to `*` passed to the
        # reference to `bar`, which sets `bar` to the reference to `*` and
        # returns`bar`.
    # Check that `bar` now contains a reference to `*`.
    bar {foo};
    !expect_eq (* []) foo;

    !expect_eq * *
}[];
# Outside of the nested expression, we can still use * as a symbol as long as it
# is not preceded by a term, since we only expect it as a token when preceded by
# a term.
!expect_eq * *;
!expect_eq (bar*) foo;

################################################################################
# Macros can be used as soon as the parser state is lower precedence than the
# new production -- even inside nested expressions.
#

!expect_eq ((\>{^`nested`;7}{{^`foo`;7}}; {^}) nested) foo;

################################################################################
# Adding a macro with very low precedence but a high-precedence first symbol.
#

\> {^`low_prec`;1} {{^`foo`;7}};
!expect_eq (low_prec) foo;

################################################################################
# Macro handler with mutable state.
#

\> {^`static`; ^{7}; 3} {^toks
    value_ref{^ ^};
    value{^ref
        value_ref{(^ref)};
        value_ref[] {undefined}
    };

    {^old_value
        ^toks {^tok
            value_ref[] {(^tok)}
        };

        {^ ^old_value; 1}
    } (value[])
};

!expect_eq (static foo) undefined;
!expect_eq (static bar) foo;
!expect_eq (static[]) bar;

################################################################################
# Macro matching uses the correct precedence for arguments.
#

sub_from_3{^} {^rhs
    3{^} {0};
    2{^} {1};
    1{^} {2};
    ^rhs[]
};

sub_from_2{^} {^rhs
    2{^} {0};
    1{^} {1};
    ^rhs[]
};

sub_from_1{^} {^rhs
    1{^} {0};
    ^rhs[]
};

subtract{^} {^lhs{^rhs
    3{^} sub_from_3;
    2{^} sub_from_2;
    1{^} sub_from_1;
    ^lhs ^rhs
}};

\> {^{7}; ^`infixr-`; ^{6}; 6} {^toks
    {
        n_ref{^ ^};
        n n_ref;
        n_ref 0;

        lhs{^ ^};
        rhs{^ ^};
        ^toks {^tok
            {
                0{^{{
                    lhs {(^tok)};
                    n_ref 1
                }}};
                1{^{{
                    n_ref 2
                }}};
                2{^{{
                    rhs {(^tok)};
                    n_ref 3
                }}};

                n[] []
            }[]
        };

        {^`subtract` `(` (lhs[]) `)``(` (rhs[]) `)`; 3}
    }[]
};

!expect_eq (3 infixr- 2) 1;
!expect_eq ((3 infixr- 2) infixr- 1) 0;
!expect_eq (3 infixr- 2 infixr- 1) 2;

\> {^{6}; ^`infixl-`; ^{7}; 6} {^toks
    {
        n_ref{^ ^};
        n n_ref;
        n_ref 0;

        lhs{^ ^};
        rhs{^ ^};
        ^toks {^tok
            {
                0{^{{
                    lhs {(^tok)};
                    n_ref 1
                }}};
                1{^{{
                    n_ref 2
                }}};
                2{^{{
                    rhs {(^tok)};
                    n_ref 3
                }}};

                n[] []
            }[]
        };

        {^`subtract` `(` (lhs[]) `)` `(` (rhs[]) `)`; 1}
    }[]
};

!expect_eq (3 infixl- 2 infixl- 1) 0;

# Mixing equal-precedence operators with different associativities causes an
# ambiguous parse error.
!expect_error { !eval `3 infixr- 2 infixl- 1` };

# But adding parentheses fixes the issue;
!expect_eq ((3 infixr- 2) infixl- 1) 0;
!expect_eq (3 infixr- (2 infixl- 1)) 2;

################################################################################
# Precedence of macro expansions matches the precedence of the macro definition.
#

\> {^`multi`; ^`token`; ^`term`; 7} {{^`{`; ^`^`; ^`}`; ^`foo`; 1}};
\> {^`requires_term`; ^{7}; 7} {^toks
    {
        n_ref{^ ^};
        n n_ref;
        n_ref 0;

        arg{^ ^};
        ^toks {^tok
            {
                0{^{{
                    n_ref 1
                }}};
                1{^{{
                    arg{(^tok)};
                    n_ref 2
                }}};

                n[] []
            }[]
        };

        {^(arg[]); 1}
    }[]
};

!expect_eq requires_term multi token term foo;

################################################################################
# Macros defined in a module can be used in an importing module.
#

!expect_eq defined_in_module `defined_in_module`;
import macro_module;
!expect_eq defined_in_module foo;

################################################################################
# A symbol with a prefix which is a keyword is still parsed as a symbol.
#

\> {^`kw_prefix`; ^{7}; 7} {^toks
    {
        n_ref{^ ^};
        n n_ref;
        n_ref 0;

        arg{^ ^};
        ^toks {^tok
            {
                0{^{{
                    n_ref 1
                }}};
                1{^{{
                    arg{(^tok)};
                    n_ref 2
                }}};
                n[] []
            }[]
        };

        {^(arg[]); 1}
    }[]
};

!expect_eq kw_prefixfoo `kw_prefixfoo`;

################################################################################
# Defining an ad-hoc non-terminal (e.g. to represent a list of symbols).
#

\> {^`\`sym\``; symbols} {^toks
    {^out
        ^toks ^out;
        ^out `nil`;
        3
    }
};

\> {^`\`sym\``; ^{symbols}; symbols} {^toks
    {
        n_ref{^ ^};
        n n_ref;
        n_ref 0;

        sym{^ ^};
        syms{^ ^};
        ^toks {^tok
            {
                0{^{{
                    sym{(^tok)};
                    n_ref 1
                }}};
                1{^{{
                    syms{(^tok)};
                    n_ref 2
                }}};

                n[] []
            }[]
        };

        {^(sym[]) {(syms[]) ^; 6}; 3}
    }[]
};

\> {^`car`; ^`(`; ^{symbols}; ^`)`; 7} {^toks
    {
        n_ref{^ ^};
        n n_ref;
        n_ref 0;

        syms{^ ^};
        ^toks {^tok
            {
                0{^{{
                    n_ref 1
                }}};
                1{^{{
                    n_ref 2
                }}};
                2{^{{
                    syms ^tok;
                    n_ref 3
                }}};
                3{^{{
                    n_ref 4
                }}};

                n[] []
            }[]
        };

        fst{^ ^};
        syms {^sym
            # ^sym looks like (((symbol ; 7) ; 6) ; 3)
            ^sym {^6 ^6{^7 ^7{^sym fst{(^sym)}}}}
        };

        {^(fst[]); 1}
    }[]
};

\> {^`cdr`; ^`(`; ^{symbols}; ^`)`; symbols} {^toks
    {
        n_ref{^ ^};
        n n_ref;
        n_ref 0;

        syms{^ ^};
        ^toks {^tok
            {
                0{^{{
                    n_ref 1
                }}};
                1{^{{
                    n_ref 2
                }}};
                2{^{{
                    syms ^tok;
                    n_ref 3
                }}};
                3{^{{
                    n_ref 4
                }}};

                n[] []
            }[]
        };

        fst_ref{^ ^};
        fst fst_ref;
        fst_ref true;

        {^out
            fst_ref{^ ^};
            fst fst_ref;
            fst_ref true;

            syms {^sym
                {
                    true{^{{
                        fst_ref false
                    }}};

                    false{^{{
                        (^out) ^sym
                    }}};

                    fst[] []
                }[]
            };
            6
        }
    }[]
};

!expect_eq car(foo) foo;
!expect_eq car(foo bar) foo;
!expect_eq car(foo bar baz) foo;
!expect_eq car(cdr(foo bar)) bar;
!expect_eq car(cdr(foo bar baz)) bar;
!expect_eq car(cdr(cdr(foo bar baz))) baz;

# We should be able to return an ad-hoc non-terminal expression from a macro
# definition by specifying the ad-hoc non-terminal for which the expression
# parses.
\> {^`cdrcdr` `(` `\`sym\`` `,` {symbols} `)`; symbols} {^toks
    {
        n_ref{^ ^};
        n n_ref;
        n_ref 0;

        nt{^ ^};
        syms{^ ^};
        ^toks {^tok
            {
                0{^{{
                    n_ref 1
                }}};
                1{^{{
                    n_ref 2
                }}};
                2{^{{
                    nt{(^tok)};
                    n_ref 3
                }}};
                3{^{{
                    n_ref 4
                }}};
                4{^{{
                    syms {(^tok)};
                    n_ref 5
                }}};
                5{^{{
                    n_ref 6
                }}};

                n[] []
            }[]
        };

        {^`cdr` `(` `cdr` `(` (syms[]) `)``)`; nt[]}
            # Does not work if the non-terminal is in the expression tree, like
            # `1`.
    }[]
};

!expect_eq car(cdrcdr(symbols, foo bar baz)) baz;
!expect_error { !eval `car(cdrcdr(1, foo bar baz))` };

################################################################################
# In a state where we expect only a symbol, any token should parse as a symbol,
# even if it would normally parse as a special token.
#

\> {^`token_or_symbol`; 7} {{^`foo`;7}};

\> {^`'` `\`sym\``; 7} {^toks
    {
        n_ref{^ ^};
        n n_ref;
        n_ref 0;

        sym{^ ^};
        ^toks {^tok
            {
                0{^{{
                    n_ref 1
                }}};
                1{^{{
                    sym{(^tok)};
                    n_ref 2
                }}};
                n[] []
            }[]
        };

        {^{^(sym[]); 7}; 6}
    }[]
};

!expect_eq token_or_symbol `foo`;
!expect_eq 'token_or_symbol `token_or_symbol`;
!expect_eq ' + `+`;

################################################################################
# In a state where we are only expecting a specific token, any other input
# should result in a parse error.
#

\> {^`special_token1` `special_token2`; 7} {{^ foo;7}};

!expect_eq special_token1 special_token2 foo;
!expect_error {
    !eval `special_token1 foo`
};

################################################################################
# Macros with nested parse trees.
#

\> {^`nested_symbol`;7} {{^{^`foo`;7}; 1}};
!expect_eq nested_symbol `foo`;

\> {^`nested_block`;7} {{^{^`{` {^`^`;7} `}`;7};1}};
!expect_eq (nested_block foo) `foo`;

\> {^`nested_send`;7} {{^{^{^`{` {^`^`;7} `}`;7} `foo`; 1}; 1}};
!expect_eq nested_send `foo`;

\> {^`nested_parens`;7} {{^{^`(` `foo` `)`; 7}; 1}};
!expect_eq nested_parens `foo`;

\> {^`nested_msg`;7} {{^{^`{` `^msg` {^`^msg`;7} `}`; 7}; 1}};
!expect_eq (nested_msg foo) `foo`;

.
