#: --skip-racket -fno-gc-tracing -fno-gc-refcount

# Tests garbage collection of local variables; that is, objects which are
# referenced by a parent object (or a parent of a parent, etc.). These seem easy
# to collect, since the references are all fairly local and acyclic. However,
# these kinds of references create cycles with the internal parent pointers,
# making collection a bit tricky.
#
# This test is similar to bench_erc_locals_named. However, unlike that test,
# where the scope with the locals is temporarily referenced by a long-lived
# object before being released, the scope containing the locals here is
# completely anonymous. This means that it never becomes entangled with the
# long-lived object, making it slightly easier to collect.

bind set symbol (
    this{.get|.}{.eval|.}{:=|that{.get|.}}
);

bind locals.create_locals_in_method (
    method_direct_local{:=|uninitialized};
    {set|method_direct_local} bar;
    method_nested_local{:=|foo};
    .
);

bind locals.init (
    self{:=|this{.get|.}};
    self{.get|.}{.eval|.};
    self{.get|.}{.create_locals_in_method|.};
    .
);

{!benchmark|n{:=|500000}} {erc_locals_anon|
    {locals|
        direct_local{:=|uninitialized};
        {set|direct_local} bar;
            # Create a local variable which is an immediate child of this block.
        nested_local{:=|foo};
            # Create a local variable which is a descendant, but not an
            # immediate child, of the owning object: foo is a child of the :=
            # block, which is a child of this object.
        .
    }{.init|.};

    .
};

{gc|.}{!print_stats|.};
{gc|.}{!expect_clean|.};
.
